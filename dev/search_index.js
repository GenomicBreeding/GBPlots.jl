var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GBPlots","category":"page"},{"location":"#GBPlots","page":"Home","title":"GBPlots","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GBPlots.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GBPlots]","category":"page"},{"location":"#GBCore.checkdims-Tuple{PlotsGB}","page":"Home","title":"GBCore.checkdims","text":"checkdims(x::PlotsGB)::Bool\n\nCheck if dimensions of labels and plots match in a PlotsGB object.\n\nArguments\n\nx::PlotsGB: A PlotsGB object containing labels and plots\n\nReturns\n\nBool: true if the number of labels equals the number of plots, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.labeltofname-Tuple{}","page":"Home","title":"GBPlots.labeltofname","text":"labeltofname(; label::String, prefix::String, suffix::String)::String\n\nConvert a label string into a valid filename by replacing special characters.\n\nThis function takes a label string and converts it into a filename-safe string by:\n\nReplacing common symbols with underscores\nAdding a prefix and suffix\nCleaning up repeated separators\n\nArguments\n\nlabel::String: The input label to be converted\nprefix::String: String to prepend to the filename\nsuffix::String: The file extension (without the dot)\n\nReturns\n\nString: A cleaned filename string with format \"prefix-label.suffix\"\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GBCore.Genomes}} where T<:CorHeatPlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    genomes::Genomes;\n    n_loci_alleles::Int64 = 1_000,\n    seed::Int64 = 42,\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n    colour_scheme::Symbol = :viridis,\n    rev_label_colors::Bool = false,\n    n_threshold_to_show_text::Int64 = 1_000,\n)::T where {T<:CorHeatPlots}\n\nCorrelation heatmaps:\n\nbetween loci_alleles across populations\nbetween entries across populations\nbetween loci_alleles per populations\nbetween entries per populations\n\nNote that we are sample n_loci_alleles to use in plotting for computational efficiency.  You may use the seed parameter for replicability.\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> hplots = GBPlots.plot(CorHeatPlots, genomes);\n\njulia> fnames = saveplots(hplots, format=\"png\")\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GBCore.Genomes}} where T<:DistributionPlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    genomes::Genomes;\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n)::T where {T<:DistributionPlots}\n\nPlot the distribution of allele frequencies from a subset of loci across populations\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> dplots = GBPlots.plot(DistributionPlots, genomes);\n\njulia> fnames = saveplots(dplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GBCore.Genomes}} where T<:PCBiPlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    genomes::Genomes;\n    n_loci_alleles::Int64 = 1_000,\n    seed::Int64 = 42,\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n    colour_scheme::Symbol = :tol_muted,\n)::T where {T<:PCBiPlots}\n\nUsing a subset of the allele frequencies, plot the first 2 principal components of the:\n\nentries\nloci-alleles\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> pplots = GBPlots.plot(PCBiPlots, genomes);\n\njulia> fnames = saveplots(pplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GBCore.Genomes}} where T<:TreePlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    genomes::Genomes;\n    n_loci_alleles::Int64 = 1_000,\n    seed::Int64 = 42,\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n    colour_scheme::Symbol = :tol_muted,\n    horizontal::Bool = true,\n)::T where {T<:TreePlots}\n\nPlot tree diagrams showing the relationships of each entry using a subset of the allele frequencies.\n\nDistance metric: Euclidean\nGrouping/linkage: Ward's distance\nBranch order: Optimal (Bar-Joseph et al, 2001. Bionformatics.)\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> tplots = GBPlots.plot(TreePlots, genomes);\n\njulia> fnames = saveplots(tplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GBCore.Genomes}} where T<:ViolinPlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    genomes::Genomes;\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n    colour_scheme::Symbol = :viridis,\n)::T where {T<:ViolinPlots}\n\nViolin plot of allele frequency distribution (for a subset of loci) per population\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> genomes = extractgenomes(trials); genomes.phenotypes[1,1] = missing;\n\njulia> vplots = GBPlots.plot(ViolinPlots, genomes);\n\njulia> fnames = saveplots(vplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GBCore.Phenomes}} where T<:CorHeatPlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    phenomes::Phenomes;\n    plot_size::Tuple{Int64, Int64} = (600, 450),\n    colour_scheme::Symbol = :viridis,\n    rev_label_colors::Bool = false,\n)::T where {T<:CorHeatPlots}\n\nCorrelation heatmaps:\n\nbetween traits across populations\nbetween entries across populations\nbetween traits per populations\nbetween entries per populations\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials); phenomes.phenotypes[1,1] = missing;\n\njulia> hplots = GBPlots.plot(CorHeatPlots, phenomes);\n\njulia> fnames = saveplots(hplots, format=\"png\")\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GBCore.Phenomes}} where T<:DistributionPlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    phenomes::Phenomes;\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n)::T where {T<:DistributionPlots}\n\nPlot distributions of each trait across populations\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials); phenomes.phenotypes[1,1] = missing;\n\njulia> dplots = GBPlots.plot(DistributionPlots, phenomes);\n\njulia> fnames = saveplots(dplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GBCore.Phenomes}} where T<:PCBiPlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    phenomes::Phenomes;\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n    colour_scheme::Symbol = :tol_muted,\n)::T where {T<:PCBiPlots}\n\nPlot the first 2 principal components of the:\n\nentries\nloci-alleles\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> pplots = GBPlots.plot(PCBiPlots, genomes);\n\njulia> fnames = saveplots(pplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GBCore.Phenomes}} where T<:TreePlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    phenomes::Phenomes;\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n    colour_scheme::Symbol = :tol_light,\n    horizontal::Bool = true,\n    standardise_traits::Bool = true,\n)::T where {T<:TreePlots}\n\nPlot tree diagrams showing the relationships of each entry using trait information.\n\nDistance metric: Euclidean\nGrouping/linkage: Ward's distance\nBranch order: Optimal (Bar-Joseph et al, 2001. Bionformatics.)\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials); phenomes.phenotypes[1,1] = missing;\n\njulia> tplots = GBPlots.plot(TreePlots, phenomes);\n\njulia> fnames = saveplots(tplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GBCore.Phenomes}} where T<:ViolinPlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    phenomes::Phenomes;\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n    colour_scheme::Symbol = :viridis,\n)::T where {T<:ViolinPlots}\n\nViolin plots per trait per population\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials); phenomes.phenotypes[1,1] = missing;\n\njulia> vplots = GBPlots.plot(ViolinPlots, phenomes);\n\njulia> fnames = saveplots(vplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, Vector{GBCore.CV}}} where T<:BarPlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    cvs::Vector{CV};\n    metric::String = \"cor\",\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n    colour_scheme::Symbol = :viridis,\n)::T where {T <: BarPlots}\n\nBar plots summarising the results of a k-fold cross-validation\n\nExamples\n\njulia> cvs::Vector{CV} = [];\n\njulia> for m in 1:3\n            for t in 1:5\n                for p in 1:4\n                    n = 100\n                    populations = if rand() < 0.5\n                        string.(\"population_\", sample(1:4, n, replace=true))\n                    else\n                        string.(\"population_\", repeat([p], n))\n                    end\n                    entries = string.(\"entry_\", sample(1:1_000, n, replace=true))\n                    for r in 1:5\n                        for f in 1:5\n                            fit = Fit(n = 10, l = 1_000); fit.model = string(\"model_\", m); fit.populations .= string(\"population_\", p); fit.trait = string(\"trait_\", t); fit.metrics = Dict(\"cor\" => rand()/maximum([1, 5*rand()]), \"rmse\" => rand())\n                            cv = CV(\n                                string(\"replication_\", r), \n                                string(\"fold_\", f), \n                                fit, \n                                populations, \n                                entries, \n                                rand(n), \n                                rand(n), \n                                fit.metrics\n                            )\n                            push!(cvs, cv)\n                        end\n                    end\n                end\n            end\n        end;\n\njulia> bplots = GBPlots.plot(BarPlots, cvs);\n\njulia> fnames = saveplots(bplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.plot-Union{Tuple{T}, Tuple{Type{T}, Vector{GBCore.CV}}} where T<:BoxPlots","page":"Home","title":"GBPlots.plot","text":"plot(\n    type::Type{T},\n    cvs::Vector{CV};\n    metric::String = \"cor\",\n    plot_size::Tuple{Int64,Int64} = (600, 450),\n    colour_scheme::Symbol = :viridis,\n)::T where {T <: BoxPlots}\n\nBox plots summarising the results of a k-fold cross-validation\n\nExamples\n\njulia> cvs::Vector{CV} = [];\n\njulia> for m in 1:3\n            for t in 1:5\n                for p in 1:4\n                    n = 100\n                    populations = if rand() < 0.5\n                        string.(\"population_\", sample(1:4, n, replace=true))\n                    else\n                        string.(\"population_\", repeat([p], n))\n                    end\n                    entries = string.(\"entry_\", sample(1:1_000, n, replace=true))\n                    for r in 1:5\n                        for f in 1:5\n                            fit = Fit(n = 10, l = 1_000); fit.model = string(\"model_\", m); fit.populations .= string(\"population_\", p); fit.trait = string(\"trait_\", t); fit.metrics = Dict(\"cor\" => rand()/maximum([1, 5*rand()]), \"rmse\" => rand())\n                            cv = CV(\n                                string(\"replication_\", r), \n                                string(\"fold_\", f), \n                                fit, \n                                populations, \n                                entries, \n                                rand(n), \n                                rand(n), \n                                fit.metrics\n                            )\n                            push!(cvs, cv)\n                        end\n                    end\n                end\n            end\n        end;\n\njulia> bplots = GBPlots.plot(BoxPlots, cvs);\n\njulia> fnames = saveplots(bplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GBPlots.saveplots-Tuple{PlotsGB}","page":"Home","title":"GBPlots.saveplots","text":"saveplots(plots::PlotsGB; idx::Vector{Int64}=[0], format::String=\"svg\", \n          prefix::String=\"\", use_labels::Bool=true, overwrite::Bool=false)::Vector{String}\n\nSave plots from a PlotsGB object to files in the specified format.\n\nArguments\n\nplots::PlotsGB: A PlotsGB object containing the plots to be saved\nidx::Vector{Int64}: Indices of plots to save. Default [0] saves all plots\nformat::String: Output file format, one of \"svg\", \"png\", or \"pdf\". Default \"svg\"\nprefix::String: Prefix for output filenames. Default uses type name of plots\nuse_labels::Bool: If true, use plot labels in filenames; if false, use numeric indices. Default true\noverwrite::Bool: If true, overwrite existing files; if false, throw error. Default false\n\nReturns\n\nVector{String}: Vector of filenames where plots were saved\n\nThrows\n\nArgumentError: If plots object is corrupted, indices are invalid, or format is unsupported\nErrorException: If attempting to overwrite existing files when overwrite=false\n\n\n\n\n\n","category":"method"}]
}
